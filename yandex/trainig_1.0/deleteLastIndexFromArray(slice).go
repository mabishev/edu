package main

import (
	"fmt"
)

func main() {
	arr2 := [][]int{
		{3, 53, 63},
		{4, 54, 74},
	}

	for i := 0; i < len(arr2); i++ {
		for j := 0; j < len(arr2[i]); j++ {
			if arr2[i][j] == 3 {
				arr2[i][j] = 63
			} else if arr2[i][j] == 63 {
				arr2[i] = append(arr2[i][:j], arr2[i][j+1:]...)
				j-- // Уменьшаем индекс, так как размер слайса уменьшился
			}
		}
	}
	fmt.Println(arr2)

	// удаление с одномерного слайса
	arr := []int{3, 53, 63, 4, 54, 74}

	for i := 0; i < len(arr); i++ {
		fmt.Println(arr[i])
		if arr[i] == 3 {
			arr[i] = 63
		} else if arr[i] == 63 {
			//arr = append(arr[:i], arr[i+1:]...)   //  Этот метод более ясен и понятен, но
			//он создает новый срез и может потребовать дополнительной памяти для копирования элементов.

			copy(arr[i:], arr[i+1:]) //Этот метод работает в пределах существующего среза и
			// не создает новый срез. Он может быть более эффективным с точки зрения памяти и
			//производительности, особенно при работе с большими данными.
			arr = arr[:len(arr)-1] // Уменьшаем длину массива на 1
			i--                    // Уменьшаем индекс, так как размер массива уменьшился
		}
	}
	fmt.Println(arr, "arr")
	//Если вам нужно удалить элементы из начала или конца среза, append
	//может быть более удобным вариантом, так как он добавляет или удаляет элементы в срезе.
	//Но если вам нужно удалить элементы из середины среза, copy может быть более эффективным вариантом.

	// нарушается очередность, но дешево по памяти, потому что вместо искомого добавбляется последний элемент
	arr3 := []int{3, 53, 63, 4, 54, 74}
	for i := 0; i < len(arr3); i++ {
		if arr3[i] == 63 {
			arr3[i] = arr3[len(arr3)-1]
			arr3 = arr3[:len(arr3)-1]
			i--
			break
		}

	}
	fmt.Println(arr3, "arr3")

}
